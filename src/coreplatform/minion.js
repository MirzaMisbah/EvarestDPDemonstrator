const model = require('../model');
const tf= require('@tensorflow/tfjs');

/**
 * Interface of classes that represent a Minion.
 * @interface
 */
class Minion {
    /**
     * Interface for an executable software component called minion.
     * @param {DataAccessService} dataAccessService: Interface for data access.
     * @param {MinionController} minionController: The minion controller to interact with.
     * @param {String} id: The id of the minion.
     * @param {Array<Object>} dependencies: List of required libraries of the minion with their URI and name within the object.
     */
    constructor(dataAccessService, minionController, id, uiAdapter = null, dependencies) {
        if (new.target === Minion) {
            throw new Error('Abstract Class cannot be instantiated.');
        }
        this.instId = null;
        this.run = false;
        this.uiAdapt = uiAdapter;

        Object.defineProperty(this, 'dataAccessService', {
            get: function () {
                return dataAccessService;
            }
        });
        Object.defineProperty(this, 'dependencies', {
            get: function () {
                return dependencies;
            }
        });

        Object.defineProperty(this, 'minionController', {
            get: function () {
                return minionController;
            }
        });

        Object.defineProperty(this, 'running', {
            get: function () {
                return this.run;
            },
            set : function (v) {
                this.run = v;
            }
        });

        Object.defineProperty(this, 'id', {
            get: function () {
                return id;
            }
        });

        Object.defineProperty(this, 'instanceId', {
            get: function () {
                return this.instId;
            },

            set(v) {
                this.instId = v;
            }
        });

        Object.defineProperty(this, 'uiAdapter', {
            get : function () {
                return this.uiAdapt;
            },

            set : function(v) {
                this.uiAdapt = v;
            }
        });
    }

    /**
     * Initializes the minion first while loading the required dependencies.
     * @return {Promise<void>}
     */
    async initialize() {
        await this._loadJSDependencies();
    }


    /**
     * Avticates a minion by loading the required dependencies and starting the minion runtime (e.g. measurement, dedicated threads etc.)
     * @return {Promise<void>}
     */
    async activate() {
        await this.initialize();
        this.running = true;
        throw new Error('You have to implement the method activate!');
    }

    /**
     * Terminates a running minion by clearing the runtime environment.
     */
    terminate() {
        this.running = false;
        throw new Error('You have to implement the method terminate!');
    }

    /**
     * Saves a minion in the local storage of the TUCANA environment.
     * @return {Promise<Object>} The status of the operation.
     */
    async saveMinionLocally() {
        let operationType = model.CRUD_OPERATION_TYPE.CREATE;
        const code = this.getCode();
        const id = this.getId();
        const swComponent = new model.SoftwareItem(id, code);
        const crudOperation = new model.CRUDOperation(operationType, model.OBJECT_TYPE.SOFTWARE, swComponent, null, null);
        return await this.dataAccessService.requestCRUDOperation(crudOperation);
    }

    /**
     * Loads a minion specified by its ID from the database.
     * @param {DataAccessService} dataAccessService: The DataAccessService.
     * @param {String} softwareItemId: The ID of the minion to load.
     * @return {Promise<Object>} The request result with the software item.
     */
    static async loadMinion(dataAccessService, softwareItemId) {
        const query = new model.DatabaseQuery(model.QUERY_TYPE.STATIC, softwareItemId, []);
        const operation = new model.CRUDOperation(model.CRUD_OPERATION_TYPE.READ, model.OBJECT_TYPE.SOFTWARE, null, query, null);
        return await dataAccessService.requestCRUDOperation(operation);
    }


    /**
     * Interprets the code of the software item.
     * @param {SoftwareItem} softwareItem: The software item.
     * @return {Class} The interpreted minion.
     */
    static interpretMinionCode(softwareItem) {
        return softwareItem.getClass();
    }


    /**
     * Notifies a minion whenever there is new data provided as input.
     * @param {*} newData: Data generated by the previous minion.
     */
    notify(newData) {
        throw new Error('You have to implement the method notify!');
    }


    /**
     * Returns the running status of the minion.
     * @return {boolean} Running or not.
     */
    getRunning() {
        return this.running;
    }

    /**
     * Sets the running status of a minion.
     * @param {boolean} running: The new running status.
     */
    setRunning(running) {
        this.running = running;
    }

    /**
     * Returns the constructor of the minion.
     * @return {Class} The constructor.
     */
    getConstructor() {
        return this.constructor;
    }

    /**
     * Loads the dependecies i.e. libraries necessary for the minion execution.
     * @return {Promise<void>}
     * @private
     */
    async _loadJSDependencies() {
        if (this.dependencies instanceof Array && this.dependencies.length > 0) {
            const fetchPromises = [];
            for (let dependency of this.dependencies) {
                try {
                    fetchPromises.push(self.fetch(dependency.uri, {
                        method: 'GET',
                        headers: {'Accept': 'application/javascript'},
                        mode: 'cors',
                        cache: 'default'
                    })
                        .then(function (res) {
                            return res.text()
                                .then(function (script) {
                                    if (script.toLowerCase() !== 'not found') {
                                        eval(script);
                                        console.log('Loaded: ' + dependency.name);
                                    }
                                });
                        }));
                } catch (e) {
                    return new Error('Not possible to load: ' + dependency.uri);
                }
            }
            return Promise.all(fetchPromises);
        } else {
            return Promise.resolve();
        }
    }

    /**
     * Returns the code i.e. the class of the minion as a string.
     * @return {String} The class string.
     */
    getCode() {
        return this.constructor.toString();
    }

    /**
     * Returns the name of the particular minion i.e. the name of the class.
     * @return {String} The minion name.
     */
    getName() {
        return this.constructor.name;
    }

    /**
     * Returns the unique ID of the particular minion
     * @return {String} The minion ID.
     */
    getId() {
        return this.id;
    }

    /**
     * Returns the unique ID of a running instance of a minion.
     * @return {String} The Instance ID.
     */
    getInstanceId() {
        return this.instanceId;
    }

    /**
     * Sets the ID of the minion.
     * @param {String} newID: The new ID
     */
    setId(newID) {
        this.id = newID;
    }

    /**
     * Sets the instance ID of the running minion.
     * @param {String} newInstanceID: The new instance ID.
     */
    setInstanceId(newInstanceID) {
        this.instanceId = newInstanceID;
    }

}

/**
 * Interface of a minion performing local data storage operations.
 * @interface
 */
class LocalDSOMinion extends Minion {

    /**
     * Abstract class for all minion types performing local data storage operations i.e. local CRUD Operations.
     * @param {DataAccessService} dataAccessService: The data access service object.
     * @param {MinionController} minionController: The minion controller.
     * @param {String} id: The id of the minion.
     * @param {Array<Object>} dependencies: The dependant libraries of this minion.
     */
    constructor(dataAccessService, minionController, id, uiAdapter=null, dependencies) {
        super(dataAccessService, minionController, id, uiAdapter, dependencies);
        if (new.target === LocalDSOMinion) {
            throw new Error('Abstract Class cannot be instantiated.');
        }
    }

    /**
     * Performs a CREATE storage operation for newly produced data
     * @param {String} id: The id of the new object.
     * @param {Object} dataObject: The data object to be created.
     * @return {Promise<Object>} The result of the storage request.
     */
    async saveData(id, dataObject) {
        const domainItem = new model.DomainItem(id, dataObject);
        const crudOperation = new model.CRUDOperation(model.CRUD_OPERATION_TYPE.CREATE, model.OBJECT_TYPE.DATA, domainItem, null, null);
        return await this.dataAccessService.requestCRUDOperation(crudOperation);
    }

    /**
     * Performs a READ storage operation on the local database.
     * @param {String} id: The identifier of the object to be read.
     * @return {Promise<Object>} The result of the operation.
     */
    async readData(id) {
        const databaseQuery = new model.DatabaseQuery(model.QUERY_TYPE.STATIC, id, []);
        const crudOperation = new model.CRUDOperation(model.CRUD_OPERATION_TYPE.READ, model.OBJECT_TYPE.DATA, null, databaseQuery, null);
        return await this.dataAccessService.requestCRUDOperation(crudOperation);
    }

    /**
     * Performs an UPDATE storage operation for produced data output.
     * @param {String} id: The identifier of the initial object.
     * @param {Object} dataObject: The updated version of the data object.
     * @return {Promise<Object>} The result of the executed operation.
     */
    async updateData(id, dataObject) {
        const databaseQuery = new model.DatabaseQuery(model.QUERY_TYPE.STATIC, id, []);
        const domainItem = new model.DomainItem(id, dataObject);
        const crudOperation = new model.CRUDOperation(model.CRUD_OPERATION_TYPE.UPDATE, model.OBJECT_TYPE.DATA, domainItem, databaseQuery, null);
        return await this.dataAccessService.requestCRUDOperation(crudOperation);
    }

    /**
     * Performs an DELETE storage operation.
     * @param {String} id: The identifier of the object to be deleted.
     * @return {Promise<Object>} The result of the executed operation.
     */
    async deleteData(id) {
        const databaseQuery = new model.DatabaseQuery(model.QUERY_TYPE.STATIC, id, []);
        const crudOperation = new model.CRUDOperation(model.CRUD_OPERATION_TYPE.DELETE, model.OBJECT_TYPE.DATA, null, databaseQuery, null);
        return await this.dataAccessService.requestCRUDOperation(crudOperation);
    }
}


/**
 * Interface of a Communicator Minion.
 * @interface
 */
class Cmin extends Minion {

    /**
     * Class for Communicator Minions with no data storage operations.
     * @param {DataAccessService} dataAccessService: The data access service object.
     * @param {MinionController} minionController: The minion controller.
     * @param {String} id: The id of the minion.
     * @param {Array<Object>} dependencies: The dependant libraries of this minion.
     */
    constructor(dataAccessService, minionController, id, uiAdapter=null, dependencies) {
        super(dataAccessService, minionController, id, uiAdapter, dependencies);
        if (new.target === Cmin) {
            throw new Error('Abstract Class cannot be instantiated.');
        }
    }

    /**
     * Broadcasts a CREATE operation.
     * @param {String} id: The identifier of the data object.
     * @param {Object} dataObject: The data object to be broadcasted.
     * @param {BroadcastConfiguration} broadcastConfiguration: The configuration of the broadcasting channels.
     * @return {Promise<Object>} The result of the operation.
     */
    async broadcastDataCreateOperation(id, dataObject, broadcastConfiguration) {
        const domainItem = new model.DomainItem(id, dataObject);
        const crudOperation = new model.CRUDOperation(model.CRUD_OPERATION_TYPE.CREATE, model.OBJECT_TYPE.DATA, domainItem, null, broadcastConfiguration);
        return await this.dataAccessService.requestCRUDOperation(crudOperation);
    }

    NewbroadcastDataCreateOperation(id, dataObject, broadcastConfiguration) {
        const domainItem = new model.DomainItem(id, dataObject);
        const crudOperation = new model.CRUDOperation(model.CRUD_OPERATION_TYPE.CREATE, model.OBJECT_TYPE.DATA, domainItem, null, broadcastConfiguration);
        this.dataAccessService.NewrequestCRUDOperation(crudOperation);
    }
    /**
     * Broadcasts a READ operation.
     * @param {String} id: The identifier of the data object.
     * @param {BroadcastConfiguration} broadcastConfiguration: The configuration of the broadcasting channels.
     * @return {Promise<Object>} The result of the operation.
     */
    async broadcastDataReadOperation(id, broadcastConfiguration) {
        const databaseQuery = new model.DatabaseQuery(model.QUERY_TYPE.STATIC, id, []);
        const crudOperation = new model.CRUDOperation(model.CRUD_OPERATION_TYPE.READ, model.OBJECT_TYPE.DATA, null, databaseQuery, broadcastConfiguration);
        return await this.dataAccessService.requestCRUDOperation(crudOperation);
    }

    /**
     * Broadcasts an UPDATE operation.
     * @param {String} id: The identifier of the data object.
     * @param {Object} dataObject: The new data object to be broadcasted.
     * @param {BroadcastConfiguration} broadcastConfiguration: The configuration of the broadcasting channels.
     * @return {Promise<Object>} The result of the operation.
     */
    async broadcastDataUpdateOperation(id, dataObject, broadcastConfiguration) {
        const domainItem = new model.DomainItem(id, dataObject);
        const databaseQuery = new model.DatabaseQuery(model.QUERY_TYPE.STATIC, id, []);
        const crudOperation = new model.CRUDOperation(model.CRUD_OPERATION_TYPE.UPDATE, model.OBJECT_TYPE.DATA, domainItem, databaseQuery, broadcastConfiguration);
        return await this.dataAccessService.requestCRUDOperation(crudOperation);
    }

    /**
     * Broadcasts a DELETE operation.
     * @param {String} id: The identifier of the data object.
     * @param {BroadcastConfiguration} broadcastConfiguration: The configuration of the broadcasting channels.
     * @return {Promise<Object>} The result of the operation.
     */
    async broadcastDataDeleteOperation(id, broadcastConfiguration) {
        const databaseQuery = new model.DatabaseQuery(model.QUERY_TYPE.STATIC, id, []);
        const crudOperation = new model.CRUDOperation(model.CRUD_OPERATION_TYPE.DELETE, model.OBJECT_TYPE.DATA, null, databaseQuery, broadcastConfiguration);
        return await this.dataAccessService.requestCRUDOperation(crudOperation);
    }
}

/**
 * Interface of a special class of Cmin with additional visualization purposes.
 * @interface
 */
class VisualizationCmin extends Cmin {
    /**
     * Contructor of the Visualization Cmin.
     * @param {DataAccessService} dataAccessService: The data access service object.
     * @param {MinionController} minionController: The minion controller.
     * @param {String} id: The id of the minion.
     * @param {*} uiAdapter
     * @param {Array<Object>} dependencies: The dependant libraries of this minion.
     */
    constructor(dataAccessService, minionController, id, uiAdapter, dependencies) {
        super(dataAccessService, minionController, id, uiAdapter, dependencies);
        if (new.target === VisualizationCmin) {
            throw new Error('Abstract Class cannot be instantiated.');
        }
    }

    /**
     * Clears the user interface.
     */
    clearUserInterface() {
        throw new Error('You have to implement the method clearUserInterface!');
    }
}

/**
 * Interface of a Thinker Minion containing local EdgeAI.
 * @interface
 */
class Tmin extends LocalDSOMinion {

    /**
     * Class for Thinker Minions supporting data storage operations.
     * @param {DataAccessService} dataAccessService: The data access service object.
     * @param {MinionController} minionController: The minion controller.
     * @param {String} id: The id of the minion.
     * @param {Array<Object>} dependencies: The dependant libraries of this minion.
     */
    constructor(dataAccessService, minionController, id, uiAdapter=null, dependencies) {
        super(dataAccessService, minionController, id, uiAdapter, dependencies);
        if (new.target === Tmin) {
            throw new Error('Abstract Class cannot be instantiated.');
        }
        this.tmpModel = null;
        Object.defineProperty(this, 'model', {
            get: function () {
                return this.tmpModel;
            },
            set : function (v) {
                this.tmpModel = v;
            }
        });
    }

    
    /**
     * Saves a model in the Indexed DB
     * @param {String} id: The identifier of the model object (For ex: gist url of the model)
     * @param {Tensor} model: The pre-trained edgeAi model.
     * @return {Promise<Object>} The result of the operation.
    */
    async createModel(id, model){
        return await model.save('indexeddb://'+id);
    } 


    /**
     * Reads a model in the Indexed DB
     * @param {String} id: The identifier of the model object (For ex: gist url of the model)
     * @return {Promise<Object>} The result of the operation. (i.e. Model)
     */
    async readModel(id) {
        var result;
        try {
       //checking model in indexDB
            result=  await tf.loadLayersModel('indexeddb://'+id);
            }catch(e1){
            //if not present, getting from gist
                try{
                    result= await tf.loadLayersModel(id);
                    await this.createModel(id, result);
                    } catch(e){   
                        console.warn(e);
                        return null;
                    }
            }
   result.summary();
   return result;
   }
    
 /**
     * Updates a model with exisitng id in the Indexed DB
     * @param {String} id: The identifier of the model object (For ex: gist url of the model)
     * @param {Tensor} model: The modified edgeAi model.
     * @return {Promise<Object>} The result of the operation.
*/    

async updateModel(id, edgeAIModel) {
    try{
         const result= await edgeAIModel.save('indexedDB://'+id);
         return result;
       }catch(e){
           return e;
       }
}
    
 /**
     * Deletes a model with exisitng id in the Indexed DB
     * @param {String} id: The identifier of the model object (For ex: gist url of the model)
     * @return {Promise<Object>} The result of the operation.
 */

async deleteModel(id){
    try{
        return await tf.io.removeModel('indexeddb://'+id);
    }
    catch(e){
            throw ('Model not found on gist');
    }    
}

 /**
     * predicts the test data using pre-trained model
     * Alternative: prediction can be done in the application speicifc Tmin
     * @param {String} testdata: Data to be tested (i.e. Received from Pmin) 
     * @return {Array} The result of the operation. (i.e. Predicitons in thr form of array)
 */

predictModel(testdata)
{
    const tensortestdata= tf.tensor3d(testdata);
    const axis=1;
    const _this = this;
    const preds= tf.tidy(()=> {
        return _this.model.predict(tensortestdata).argMax(axis);
    });
    return Array.from(preds.dataSync());
}

}

/**
 * Interface of a Perceiver Minion performing perception of data and similar tasks.
 * @interface
 */
class Pmin extends LocalDSOMinion {

    /**
     * Class for Perceiver Minions supporting data storage operations.
     * @param {DataAccessService} dataAccessService: The data access service object.
     * @param {MinionController} minionController: The minion controller.
     * @param {String} id: The id of the minion.
     * @param {Array<Object>} dependencies: The dependant libraries of this minion.
     */
    constructor(dataAccessService, minionController, id, uiAdapter=null, dependencies) {
        super(dataAccessService, minionController, id, uiAdapter=null, dependencies);
        if (new.target === Pmin) {
            throw new Error('Abstract Class cannot be instantiated.');
        }
    }
}

module.exports.Minion = Minion;
module.exports.LocalDSOMinion = LocalDSOMinion;
module.exports.Cmin = Cmin;
module.exports.VisualizationCmin = VisualizationCmin;
module.exports.Pmin = Pmin;
module.exports.Tmin = Tmin;
module.exports.tf= tf;
