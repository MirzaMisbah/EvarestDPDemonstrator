

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Source: adapter.js | TUCANA Documentation</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/tui-doc.css">

    
</head>
<body>
<nav class="lnb" id="lnb">
    <div class="logo" style="width: 90px; height: 30px">
        
            <a href="https://github.com/InformationServiceSystems/tucana" rel="noopener noreferrer" target="_blank">
                <img src="http://iss.uni-saarland.de/workspace/grayscale/img/logo_iss1.png" width="100%" height="100%">
            </a>
        
    </div>
    <div class="title">
        <h1><a href="index.html" class="link">TUCANA Documentation</a></h1>
        
    </div>
    <div class="search-container" id="search-container">
        <input type="text" placeholder="Search">
        <ul></ul>
    </div>
    
    <div class="lnb-api hidden"><h3>Classes</h3><ul><li><a href="AwaitBroadcastResponse.html">AwaitBroadcastResponse</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="AwaitBroadcastResponse_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="AwaitBroadcastResponse.html#ressourceNotAvailable">ressourceNotAvailable</a></li><li><a href="AwaitBroadcastResponse.html#ressourceProtected">ressourceProtected</a></li><li><a href="AwaitBroadcastResponse.html#ressourceProvided">ressourceProvided</a></li><li><a href="AwaitBroadcastResponse.html#toString">toString</a></li></ul></div></li><li><a href="BaaSCommunicationHandler.html">BaaSCommunicationHandler</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="BaaSCommunicationHandler_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="BaaSCommunicationHandler.html#broadcastDBaaS">broadcastDBaaS</a></li><li><a href="BaaSCommunicationHandler.html#broadcastMBaaS">broadcastMBaaS</a></li><li><a href="BaaSCommunicationHandler.html#broadcastRessourceAccess">broadcastRessourceAccess</a></li><li><a href="BaaSCommunicationHandler.html#broadcastSBaaS">broadcastSBaaS</a></li><li><a href="BaaSCommunicationHandler.html#broadcastSSCBaaS">broadcastSSCBaaS</a></li></ul></div></li><li><a href="BroadcastConfiguration.html">BroadcastConfiguration</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="BroadcastConfiguration_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="BroadcastConfiguration.html#.fromJSON">fromJSON</a></li><li><a href="BroadcastConfiguration.html#getBroadcastCondition">getBroadcastCondition</a></li><li><a href="BroadcastConfiguration.html#getSource">getSource</a></li><li><a href="BroadcastConfiguration.html#getTargets">getTargets</a></li><li><a href="BroadcastConfiguration.html#getTrigger">getTrigger</a></li><li><a href="BroadcastConfiguration.html#getType">getType</a></li><li><a href="BroadcastConfiguration.html#toJSON">toJSON</a></li></ul></div></li><li><a href="BroadcastRequestReceived.html">BroadcastRequestReceived</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="BroadcastRequestReceived_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="BroadcastRequestReceived.html#broadcastRessourceAccess">broadcastRessourceAccess</a></li><li><a href="BroadcastRequestReceived.html#toString">toString</a></li></ul></div></li><li><a href="BrowserFingerprintIdentificationHandler.html">BrowserFingerprintIdentificationHandler</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="BrowserFingerprintIdentificationHandler_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="BrowserFingerprintIdentificationHandler.html#getContentOffering">getContentOffering</a></li><li><a href="BrowserFingerprintIdentificationHandler.html#getGeography">getGeography</a></li><li><a href="BrowserFingerprintIdentificationHandler.html#getKeywords">getKeywords</a></li><li><a href="BrowserFingerprintIdentificationHandler.html#getLocalID">getLocalID</a></li><li><a href="BrowserFingerprintIdentificationHandler.html#getModelOffering">getModelOffering</a></li><li><a href="BrowserFingerprintIdentificationHandler.html#getName">getName</a></li><li><a href="BrowserFingerprintIdentificationHandler.html#getProperties">getProperties</a></li><li><a href="BrowserFingerprintIdentificationHandler.html#getSoftwareOffering">getSoftwareOffering</a></li><li><a href="BrowserFingerprintIdentificationHandler.html#getType">getType</a></li></ul></div></li><li><a href="Cmin.html">Cmin</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Cmin_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Cmin.html#broadcastDataCreateOperation">broadcastDataCreateOperation</a></li><li><a href="Cmin.html#broadcastDataDeleteOperation">broadcastDataDeleteOperation</a></li><li><a href="Cmin.html#broadcastDataReadOperation">broadcastDataReadOperation</a></li><li><a href="Cmin.html#broadcastDataUpdateOperation">broadcastDataUpdateOperation</a></li></ul></div></li><li><a href="CRUDOperation.html">CRUDOperation</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="CRUDOperation_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="CRUDOperation.html#.fromJSON">fromJSON</a></li><li><a href="CRUDOperation.html#getBroadcastConfiguration">getBroadcastConfiguration</a></li><li><a href="CRUDOperation.html#getBroadcastTargets">getBroadcastTargets</a></li><li><a href="CRUDOperation.html#getObject">getObject</a></li><li><a href="CRUDOperation.html#getObjectType">getObjectType</a></li><li><a href="CRUDOperation.html#getOperationType">getOperationType</a></li><li><a href="CRUDOperation.html#getQuery">getQuery</a></li><li><a href="CRUDOperation.html#setBroadcastConfiguration">setBroadcastConfiguration</a></li><li><a href="CRUDOperation.html#setObject">setObject</a></li><li><a href="CRUDOperation.html#setObjectType">setObjectType</a></li><li><a href="CRUDOperation.html#setOperationType">setOperationType</a></li><li><a href="CRUDOperation.html#setQuery">setQuery</a></li><li><a href="CRUDOperation.html#toJSON">toJSON</a></li></ul></div></li><li><a href="DataAccessController.html">DataAccessController</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="DataAccessController_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="DataAccessController.html#broadcastRessourceAccess">broadcastRessourceAccess</a></li><li><a href="DataAccessController.html#executeCRUDOperation">executeCRUDOperation</a></li><li><a href="DataAccessController.html#executeLocalCRUDOperation">executeLocalCRUDOperation</a></li><li><a href="DataAccessController.html#getDomainItemIds">getDomainItemIds</a></li><li><a href="DataAccessController.html#getFilteredPeerIds">getFilteredPeerIds</a></li><li><a href="DataAccessController.html#getLocalID">getLocalID</a></li><li><a href="DataAccessController.html#getModelItemIds">getModelItemIds</a></li><li><a href="DataAccessController.html#getProperties">getProperties</a></li><li><a href="DataAccessController.html#getSmartServiceConfigurationItemIds">getSmartServiceConfigurationItemIds</a></li><li><a href="DataAccessController.html#getSoftwareItemIds">getSoftwareItemIds</a></li><li><a href="DataAccessController.html#requestAccessPermission">requestAccessPermission</a></li></ul></div></li><li><a href="DataAccessService.html">DataAccessService</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="DataAccessService_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="DataAccessService.html#getDomainItemIds">getDomainItemIds</a></li><li><a href="DataAccessService.html#getFilteredPeerIds">getFilteredPeerIds</a></li><li><a href="DataAccessService.html#getLocalID">getLocalID</a></li><li><a href="DataAccessService.html#getModelItemIds">getModelItemIds</a></li><li><a href="DataAccessService.html#getProperties">getProperties</a></li><li><a href="DataAccessService.html#getSmartServiceConfigurationItemIds">getSmartServiceConfigurationItemIds</a></li><li><a href="DataAccessService.html#getSoftwareItemIds">getSoftwareItemIds</a></li></ul></div></li><li><a href="DatabaseHandler.html">DatabaseHandler</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="DatabaseHandler_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="DatabaseHandler.html#_createData">_createData</a></li><li><a href="DatabaseHandler.html#_createModel">_createModel</a></li><li><a href="DatabaseHandler.html#_createSmartServiceConfiguration">_createSmartServiceConfiguration</a></li><li><a href="DatabaseHandler.html#_createSoftwareComponent">_createSoftwareComponent</a></li><li><a href="DatabaseHandler.html#_deleteData">_deleteData</a></li><li><a href="DatabaseHandler.html#_deleteModel">_deleteModel</a></li><li><a href="DatabaseHandler.html#_deleteSmartServiceConfiguration">_deleteSmartServiceConfiguration</a></li><li><a href="DatabaseHandler.html#_deleteSoftwareComponent">_deleteSoftwareComponent</a></li><li><a href="DatabaseHandler.html#_readData">_readData</a></li><li><a href="DatabaseHandler.html#_readModel">_readModel</a></li><li><a href="DatabaseHandler.html#_readSmartServiceConfiguration">_readSmartServiceConfiguration</a></li><li><a href="DatabaseHandler.html#_readSoftwareComponent">_readSoftwareComponent</a></li><li><a href="DatabaseHandler.html#_updateData">_updateData</a></li><li><a href="DatabaseHandler.html#_updateModel">_updateModel</a></li><li><a href="DatabaseHandler.html#_updateSmartServiceConfiguration">_updateSmartServiceConfiguration</a></li><li><a href="DatabaseHandler.html#_updateSoftwareComponent">_updateSoftwareComponent</a></li><li><a href="DatabaseHandler.html#create">create</a></li><li><a href="DatabaseHandler.html#delete">delete</a></li><li><a href="DatabaseHandler.html#executeLocalCRUDOperation">executeLocalCRUDOperation</a></li><li><a href="DatabaseHandler.html#getDomainItemIDs">getDomainItemIDs</a></li><li><a href="DatabaseHandler.html#getModelItemIDs">getModelItemIDs</a></li><li><a href="DatabaseHandler.html#getSmartServiceConfigurationItemIDs">getSmartServiceConfigurationItemIDs</a></li><li><a href="DatabaseHandler.html#getSoftwareItemIDs">getSoftwareItemIDs</a></li><li><a href="DatabaseHandler.html#read">read</a></li><li><a href="DatabaseHandler.html#update">update</a></li></ul></div></li><li><a href="DatabaseQuery.html">DatabaseQuery</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="DatabaseQuery_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="DatabaseQuery.html#.fromJSON">fromJSON</a></li><li><a href="DatabaseQuery.html#getParams">getParams</a></li><li><a href="DatabaseQuery.html#getQueryType">getQueryType</a></li><li><a href="DatabaseQuery.html#getRessource">getRessource</a></li><li><a href="DatabaseQuery.html#toJSON">toJSON</a></li><li><a href="DatabaseQuery.html#toURI">toURI</a></li></ul></div></li><li><a href="DataRequestStateController.html">DataRequestStateController</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="DataRequestStateController_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="DataRequestStateController.html#broadcastOperationExecuted">broadcastOperationExecuted</a></li><li><a href="DataRequestStateController.html#broadcastRessourceAccess">broadcastRessourceAccess</a></li><li><a href="DataRequestStateController.html#cancelBroadcastOperation">cancelBroadcastOperation</a></li><li><a href="DataRequestStateController.html#executeLocalOperation">executeLocalOperation</a></li><li><a href="DataRequestStateController.html#getAwaitBroadcastResponse">getAwaitBroadcastResponse</a></li><li><a href="DataRequestStateController.html#getBroadcastRequestReceived">getBroadcastRequestReceived</a></li><li><a href="DataRequestStateController.html#getCurrentState">getCurrentState</a></li><li><a href="DataRequestStateController.html#getIdle">getIdle</a></li><li><a href="DataRequestStateController.html#getRequestReceived">getRequestReceived</a></li><li><a href="DataRequestStateController.html#getRessourceAccessNotAvailable">getRessourceAccessNotAvailable</a></li><li><a href="DataRequestStateController.html#getRessourceAccessProtected">getRessourceAccessProtected</a></li><li><a href="DataRequestStateController.html#getRessourceAccessProvided">getRessourceAccessProvided</a></li><li><a href="DataRequestStateController.html#requestBroadcastCRUDOperation">requestBroadcastCRUDOperation</a></li><li><a href="DataRequestStateController.html#requestCRUDOperation">requestCRUDOperation</a></li><li><a href="DataRequestStateController.html#requestRessourceAccess">requestRessourceAccess</a></li><li><a href="DataRequestStateController.html#ressourceNotAvailable">ressourceNotAvailable</a></li><li><a href="DataRequestStateController.html#ressourceProtected">ressourceProtected</a></li><li><a href="DataRequestStateController.html#ressourceProvided">ressourceProvided</a></li><li><a href="DataRequestStateController.html#setCurrentState">setCurrentState</a></li></ul></div></li><li><a href="DomainItem.html">DomainItem</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="DomainItem_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="DomainItem.html#.fromJSON">fromJSON</a></li><li><a href="DomainItem.html#getId">getId</a></li><li><a href="DomainItem.html#getObject">getObject</a></li><li><a href="DomainItem.html#setId">setId</a></li><li><a href="DomainItem.html#setObject">setObject</a></li><li><a href="DomainItem.html#toJSON">toJSON</a></li></ul></div></li><li><a href="ExecutionFailed.html">ExecutionFailed</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="ExecutionFailed_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="ExecutionFailed.html#cancel">cancel</a></li></ul></div></li><li><a href="ExecutionPossible.html">ExecutionPossible</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="ExecutionPossible_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="ExecutionPossible.html#bindMinions">bindMinions</a></li></ul></div></li><li><a href="ExecutionProtected.html">ExecutionProtected</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="ExecutionProtected_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="ExecutionProtected.html#cancel">cancel</a></li><li><a href="ExecutionProtected.html#removeProtection">removeProtection</a></li></ul></div></li><li><a href="FeatureRequest.html">FeatureRequest</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="FeatureRequest_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="FeatureRequest.html#.fromJSON">fromJSON</a></li><li><a href="FeatureRequest.html#getCRUDOperation">getCRUDOperation</a></li><li><a href="FeatureRequest.html#getId">getId</a></li><li><a href="FeatureRequest.html#getTrigger">getTrigger</a></li><li><a href="FeatureRequest.html#getType">getType</a></li><li><a href="FeatureRequest.html#toJSON">toJSON</a></li></ul></div></li><li><a href="FeatureResponse.html">FeatureResponse</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="FeatureResponse_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="FeatureResponse.html#.fromJSON">fromJSON</a></li><li><a href="FeatureResponse.html#getRequest">getRequest</a></li><li><a href="FeatureResponse.html#getResult">getResult</a></li><li><a href="FeatureResponse.html#toJSON">toJSON</a></li></ul></div></li><li><a href="Idle.html">Idle</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Idle_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Idle.html#getSmartServiceConfigurationItemIds">getSmartServiceConfigurationItemIds</a></li><li><a href="Idle.html#loadSmartServiceConfiguration">loadSmartServiceConfiguration</a></li><li><a href="Idle.html#requestCRUDOperation">requestCRUDOperation</a></li><li><a href="Idle.html#toString">toString</a></li></ul></div></li><li><a href="LocalDSOMinion.html">LocalDSOMinion</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="LocalDSOMinion_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="LocalDSOMinion.html#deleteData">deleteData</a></li><li><a href="LocalDSOMinion.html#readData">readData</a></li><li><a href="LocalDSOMinion.html#saveData">saveData</a></li><li><a href="LocalDSOMinion.html#updateData">updateData</a></li></ul></div></li><li><a href="Minion.html">Minion</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Minion_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Minion.html#.interpretMinionCode">interpretMinionCode</a></li><li><a href="Minion.html#.loadMinion">loadMinion</a></li><li><a href="Minion.html#activate">activate</a></li><li><a href="Minion.html#getCode">getCode</a></li><li><a href="Minion.html#getConstructor">getConstructor</a></li><li><a href="Minion.html#getId">getId</a></li><li><a href="Minion.html#getInstanceId">getInstanceId</a></li><li><a href="Minion.html#getName">getName</a></li><li><a href="Minion.html#getRunning">getRunning</a></li><li><a href="Minion.html#initialize">initialize</a></li><li><a href="Minion.html#notify">notify</a></li><li><a href="Minion.html#saveMinionLocally">saveMinionLocally</a></li><li><a href="Minion.html#setId">setId</a></li><li><a href="Minion.html#setInstanceId">setInstanceId</a></li><li><a href="Minion.html#setRunning">setRunning</a></li><li><a href="Minion.html#terminate">terminate</a></li></ul></div></li><li><a href="MinionCommunicationMap.html">MinionCommunicationMap</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="MinionCommunicationMap_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="MinionCommunicationMap.html#addMinion">addMinion</a></li><li><a href="MinionCommunicationMap.html#addTransition">addTransition</a></li><li><a href="MinionCommunicationMap.html#getColumnRows">getColumnRows</a></li><li><a href="MinionCommunicationMap.html#getMap">getMap</a></li><li><a href="MinionCommunicationMap.html#getSourceMinionIDs">getSourceMinionIDs</a></li><li><a href="MinionCommunicationMap.html#getTargetMinionIDs">getTargetMinionIDs</a></li><li><a href="MinionCommunicationMap.html#removeTransition">removeTransition</a></li></ul></div></li><li><a href="MinionController.html">MinionController</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="MinionController_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="MinionController.html#activate">activate</a></li><li><a href="MinionController.html#bind">bind</a></li><li><a href="MinionController.html#clearRuntimeEnvironment">clearRuntimeEnvironment</a></li><li><a href="MinionController.html#getMinionClass">getMinionClass</a></li><li><a href="MinionController.html#getMinionClasses">getMinionClasses</a></li><li><a href="MinionController.html#notify">notify</a></li><li><a href="MinionController.html#register">register</a></li><li><a href="MinionController.html#terminate">terminate</a></li></ul></div></li><li><a href="MinionMatchingChecked.html">MinionMatchingChecked</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="MinionMatchingChecked_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="MinionMatchingChecked.html#allMinionsAvailable">allMinionsAvailable</a></li><li><a href="MinionMatchingChecked.html#someMinionNotAvailable">someMinionNotAvailable</a></li><li><a href="MinionMatchingChecked.html#someMinionProtected">someMinionProtected</a></li></ul></div></li><li><a href="MinionsBound.html">MinionsBound</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="MinionsBound_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="MinionsBound.html#runSmartService">runSmartService</a></li></ul></div></li><li><a href="MinionSpecification.html">MinionSpecification</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="MinionSpecification_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="MinionSpecification.html#.fromJSON">fromJSON</a></li><li><a href="MinionSpecification.html#getDescription">getDescription</a></li><li><a href="MinionSpecification.html#getInstanceId">getInstanceId</a></li><li><a href="MinionSpecification.html#getName">getName</a></li><li><a href="MinionSpecification.html#getSoftwareItemId">getSoftwareItemId</a></li><li><a href="MinionSpecification.html#getTargetMinionIds">getTargetMinionIds</a></li><li><a href="MinionSpecification.html#getType">getType</a></li><li><a href="MinionSpecification.html#setInstanceId">setInstanceId</a></li><li><a href="MinionSpecification.html#toJSON">toJSON</a></li></ul></div></li><li><a href="MinionState.html">MinionState</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="MinionState_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="MinionState.html#allMinionsAvailable">allMinionsAvailable</a></li><li><a href="MinionState.html#bindMinions">bindMinions</a></li><li><a href="MinionState.html#cancel">cancel</a></li><li><a href="MinionState.html#checkMinionMatching">checkMinionMatching</a></li><li><a href="MinionState.html#deliverSmartServiceConfigurationItemIds">deliverSmartServiceConfigurationItemIds</a></li><li><a href="MinionState.html#getSmartServiceConfigurationItemIds">getSmartServiceConfigurationItemIds</a></li><li><a href="MinionState.html#loadSmartServiceConfiguration">loadSmartServiceConfiguration</a></li><li><a href="MinionState.html#removeProtection">removeProtection</a></li><li><a href="MinionState.html#runSmartService">runSmartService</a></li><li><a href="MinionState.html#someMinionNotAvailable">someMinionNotAvailable</a></li><li><a href="MinionState.html#someMinionProtected">someMinionProtected</a></li><li><a href="MinionState.html#terminateSmartService">terminateSmartService</a></li></ul></div></li><li><a href="MinionStateController.html">MinionStateController</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="MinionStateController_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="MinionStateController.html#allMinionsAvailable">allMinionsAvailable</a></li><li><a href="MinionStateController.html#bindMinions">bindMinions</a></li><li><a href="MinionStateController.html#cancel">cancel</a></li><li><a href="MinionStateController.html#checkMinionMatching">checkMinionMatching</a></li><li><a href="MinionStateController.html#deliverSmartServiceConfigurationItemIds">deliverSmartServiceConfigurationItemIds</a></li><li><a href="MinionStateController.html#getCurrentState">getCurrentState</a></li><li><a href="MinionStateController.html#getExecutionFailed">getExecutionFailed</a></li><li><a href="MinionStateController.html#getExecutionPossible">getExecutionPossible</a></li><li><a href="MinionStateController.html#getExecutionProtected">getExecutionProtected</a></li><li><a href="MinionStateController.html#getIdle">getIdle</a></li><li><a href="MinionStateController.html#getMinionMatchingChecked">getMinionMatchingChecked</a></li><li><a href="MinionStateController.html#getMinionsBound">getMinionsBound</a></li><li><a href="MinionStateController.html#getSmartServiceConfigurationItemIds">getSmartServiceConfigurationItemIds</a></li><li><a href="MinionStateController.html#getSmartServiceConfigurationLoaded">getSmartServiceConfigurationLoaded</a></li><li><a href="MinionStateController.html#getSmartServiceConfigurationsFound">getSmartServiceConfigurationsFound</a></li><li><a href="MinionStateController.html#getSmartServiceRunning">getSmartServiceRunning</a></li><li><a href="MinionStateController.html#loadSmartServiceConfiguration">loadSmartServiceConfiguration</a></li><li><a href="MinionStateController.html#removeProtection">removeProtection</a></li><li><a href="MinionStateController.html#runSmartService">runSmartService</a></li><li><a href="MinionStateController.html#setCurrentState">setCurrentState</a></li><li><a href="MinionStateController.html#someMinionNotAvailable">someMinionNotAvailable</a></li><li><a href="MinionStateController.html#someMinionProtected">someMinionProtected</a></li><li><a href="MinionStateController.html#terminateSmartService">terminateSmartService</a></li></ul></div></li><li><a href="ModelItem.html">ModelItem</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="ModelItem_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="ModelItem.html#.fromJSON">fromJSON</a></li><li><a href="ModelItem.html#getId">getId</a></li><li><a href="ModelItem.html#getModel">getModel</a></li><li><a href="ModelItem.html#setId">setId</a></li><li><a href="ModelItem.html#setModel">setModel</a></li><li><a href="ModelItem.html#toJSON">toJSON</a></li></ul></div></li><li><a href="Pmin.html">Pmin</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Pmin_sub"></div></li><li><a href="RequestReceived.html">RequestReceived</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="RequestReceived_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="RequestReceived.html#executeLocalOperation">executeLocalOperation</a></li><li><a href="RequestReceived.html#requestBroadcastCRUDOperation">requestBroadcastCRUDOperation</a></li><li><a href="RequestReceived.html#toString">toString</a></li></ul></div></li><li><a href="RessourceAccessNotAvailable.html">RessourceAccessNotAvailable</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="RessourceAccessNotAvailable_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="RessourceAccessNotAvailable.html#cancelBroadcastOperation">cancelBroadcastOperation</a></li><li><a href="RessourceAccessNotAvailable.html#toString">toString</a></li></ul></div></li><li><a href="RessourceAccessProtected.html">RessourceAccessProtected</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="RessourceAccessProtected_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="RessourceAccessProtected.html#cancelBroadcastOperation">cancelBroadcastOperation</a></li><li><a href="RessourceAccessProtected.html#requestRessourceAccess">requestRessourceAccess</a></li></ul></div></li><li><a href="RessourceAccessProvided.html">RessourceAccessProvided</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="RessourceAccessProvided_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="RessourceAccessProvided.html#broadcastOperationExecuted">broadcastOperationExecuted</a></li><li><a href="RessourceAccessProvided.html#toString">toString</a></li></ul></div></li><li><a href="SmartServiceConfigurationItem.html">SmartServiceConfigurationItem</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="SmartServiceConfigurationItem_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="SmartServiceConfigurationItem.html#.fromJSON">fromJSON</a></li><li><a href="SmartServiceConfigurationItem.html#getConfiguration">getConfiguration</a></li><li><a href="SmartServiceConfigurationItem.html#getContext">getContext</a></li><li><a href="SmartServiceConfigurationItem.html#getDescriptionText">getDescriptionText</a></li><li><a href="SmartServiceConfigurationItem.html#getDescriptionTitle">getDescriptionTitle</a></li><li><a href="SmartServiceConfigurationItem.html#getId">getId</a></li><li><a href="SmartServiceConfigurationItem.html#getName">getName</a></li><li><a href="SmartServiceConfigurationItem.html#getVersion">getVersion</a></li><li><a href="SmartServiceConfigurationItem.html#toJSON">toJSON</a></li></ul></div></li><li><a href="SmartServiceConfigurationLoaded.html">SmartServiceConfigurationLoaded</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="SmartServiceConfigurationLoaded_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="SmartServiceConfigurationLoaded.html#checkMinionMatching">checkMinionMatching</a></li></ul></div></li><li><a href="SmartServiceConfigurationsFound.html">SmartServiceConfigurationsFound</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="SmartServiceConfigurationsFound_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="SmartServiceConfigurationsFound.html#deliverSmartServiceConfigurationItemIds">deliverSmartServiceConfigurationItemIds</a></li></ul></div></li><li><a href="SmartServiceController.html">SmartServiceController</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="SmartServiceController_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="SmartServiceController.html#activateLoadedService">activateLoadedService</a></li><li><a href="SmartServiceController.html#bindMinions">bindMinions</a></li><li><a href="SmartServiceController.html#getDataAccessService">getDataAccessService</a></li><li><a href="SmartServiceController.html#getMinionController">getMinionController</a></li><li><a href="SmartServiceController.html#getSmartServiceConfigurationItemIds">getSmartServiceConfigurationItemIds</a></li><li><a href="SmartServiceController.html#loadSmartServiceConfiguration">loadSmartServiceConfiguration</a></li><li><a href="SmartServiceController.html#match">match</a></li><li><a href="SmartServiceController.html#notifyMinions">notifyMinions</a></li><li><a href="SmartServiceController.html#removeProtections">removeProtections</a></li><li><a href="SmartServiceController.html#terminateRunningService">terminateRunningService</a></li></ul></div></li><li><a href="SmartServiceRunning.html">SmartServiceRunning</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="SmartServiceRunning_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="SmartServiceRunning.html#terminateSmartService">terminateSmartService</a></li></ul></div></li><li><a href="SoftwareItem.html">SoftwareItem</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="SoftwareItem_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="SoftwareItem.html#.fromJSON">fromJSON</a></li><li><a href="SoftwareItem.html#getClass">getClass</a></li><li><a href="SoftwareItem.html#getCode">getCode</a></li><li><a href="SoftwareItem.html#getId">getId</a></li><li><a href="SoftwareItem.html#setCode">setCode</a></li><li><a href="SoftwareItem.html#setId">setId</a></li><li><a href="SoftwareItem.html#toJSON">toJSON</a></li></ul></div></li><li><a href="TENVIdentificationHandler.html">TENVIdentificationHandler</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="TENVIdentificationHandler_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="TENVIdentificationHandler.html#getContentOffering">getContentOffering</a></li><li><a href="TENVIdentificationHandler.html#getGeography">getGeography</a></li><li><a href="TENVIdentificationHandler.html#getKeywords">getKeywords</a></li><li><a href="TENVIdentificationHandler.html#getLocalID">getLocalID</a></li><li><a href="TENVIdentificationHandler.html#getModelOffering">getModelOffering</a></li><li><a href="TENVIdentificationHandler.html#getName">getName</a></li><li><a href="TENVIdentificationHandler.html#getProperties">getProperties</a></li><li><a href="TENVIdentificationHandler.html#getSoftwareOffering">getSoftwareOffering</a></li><li><a href="TENVIdentificationHandler.html#getType">getType</a></li></ul></div></li><li><a href="Tmin.html">Tmin</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Tmin_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Tmin.html#createModel">createModel</a></li><li><a href="Tmin.html#deleteModel">deleteModel</a></li><li><a href="Tmin.html#predictModel">predictModel</a></li><li><a href="Tmin.html#readModel">readModel</a></li><li><a href="Tmin.html#updateModel">updateModel</a></li></ul></div></li><li><a href="Trigger.html">Trigger</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Trigger_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Trigger.html#.fromJSON">fromJSON</a></li><li><a href="Trigger.html#getMinionSpecs">getMinionSpecs</a></li><li><a href="Trigger.html#getTriggerMethod">getTriggerMethod</a></li><li><a href="Trigger.html#toJSON">toJSON</a></li></ul></div></li><li><a href="TucanaCoreService.html">TucanaCoreService</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="TucanaCoreService_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="TucanaCoreService.html#notifyMinions">notifyMinions</a></li><li><a href="TucanaCoreService.html#requestCRUDOperation">requestCRUDOperation</a></li><li><a href="TucanaCoreService.html#startService">startService</a></li></ul></div></li><li><a href="UPeerCommunicationHandler.html">UPeerCommunicationHandler</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="UPeerCommunicationHandler_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="UPeerCommunicationHandler.html#_executeBroadcastCRUDOperation">_executeBroadcastCRUDOperation</a></li><li><a href="UPeerCommunicationHandler.html#answer">answer</a></li><li><a href="UPeerCommunicationHandler.html#broadcastRessourceAccess">broadcastRessourceAccess</a></li><li><a href="UPeerCommunicationHandler.html#connectToCore">connectToCore</a></li><li><a href="UPeerCommunicationHandler.html#getFilteredPeerIds">getFilteredPeerIds</a></li><li><a href="UPeerCommunicationHandler.html#handleCRUDOperation">handleCRUDOperation</a></li><li><a href="UPeerCommunicationHandler.html#handleRequest">handleRequest</a></li><li><a href="UPeerCommunicationHandler.html#handleResponse">handleResponse</a></li><li><a href="UPeerCommunicationHandler.html#handleTrigger">handleTrigger</a></li><li><a href="UPeerCommunicationHandler.html#init">init</a></li><li><a href="UPeerCommunicationHandler.html#requestAccessPermission">requestAccessPermission</a></li><li><a href="UPeerCommunicationHandler.html#setupEventListener">setupEventListener</a></li><li><a href="UPeerCommunicationHandler.html#transfer">transfer</a></li></ul></div></li><li><a href="VisualizationCmin.html">VisualizationCmin</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="VisualizationCmin_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="VisualizationCmin.html#clearUserInterface">clearUserInterface</a></li></ul></div></li></ul></div><div class="lnb-api hidden"><h3>Global</h3><ul><li><a href="global.html#BROADCAST_CONDITION">BROADCAST_CONDITION</a></li><li><a href="global.html#BROADCAST_TYPE">BROADCAST_TYPE</a></li><li><a href="global.html#CRUD_OPERATION_TYPE">CRUD_OPERATION_TYPE</a></li><li><a href="global.html#MINION_TYPE">MINION_TYPE</a></li><li><a href="global.html#OBJECT_TYPE">OBJECT_TYPE</a></li><li><a href="global.html#QUERY_TYPE">QUERY_TYPE</a></li><li><a href="global.html#REQUEST_TYPE">REQUEST_TYPE</a></li><li><a href="global.html#RESPONSE_STATUS">RESPONSE_STATUS</a></li></ul></div>
</nav>
<div id="resizer"></div>

<div class="main" id="main">
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const DatabaseHandler = require('./dataallocation/handler/databasehandler').DatabaseHandler;
const UPeerCommunicationHandler = require('./dataallocation/handler/peercommunicationhandler').UPeerCommunicationHandler;
const BaaSCommunicationHandler = require('./dataallocation/handler/baascommunicationhandler').BaaSCommunicationHandler;
const TENVIdentificationHandler = require('./dataallocation/handler/tenvidentificationhandler').TENVIdentificationHandler;
const model = require('./model');
const Fingerprint2 = require('fingerprintjs2');


class IndexedDBDatabaseHandler extends DatabaseHandler {
    constructor() {
        super();
        this.dataDB = 'data';
        this.modelDB = 'model';
        this.swCompDB = 'swComponent';
        this.sscItemDB = 'sscItem';

        this.dataTable = 'data';
        this.modelTable = 'model';
        this.softwareComponentsTable = 'swComponent';
        this.smartServiceConfigurationTable = 'sscItem';
    }


    /**
     * Creates a new model object.
     * @param object: The object to create.
     * @return {Promise&lt;boolean>} Success or not
     */
    async _createModel(object){
        const _this = this;
        return new Promise(
            function(resolve, reject) {
                if (object.id === undefined) resolve(null);
                var dbRequest = indexedDB.open(_this.modelDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    var database    = event.target.result;
                    var objectStore = database.createObjectStore(_this.modelTable, {keyPath: "id"});
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{    
                        var transaction   = database.transaction([_this.modelTable], 'readwrite');
                        var objectStore   = transaction.objectStore(_this.modelTable);
                        var objectRequest = objectStore.put(object);

                        objectRequest.onerror = function(event) {
                            resolve(false);
                        };

                        objectRequest.onsuccess = function(event) {
                            resolve(true);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }


    /**
     * Creates a new data object.
     * @param object: The object to create.
     * @return {Promise&lt;boolean>} Success or not
     */
    async _createData(object){
        const _this = this;
        return new Promise(
            function(resolve, reject) {
                if (object.id === undefined) resolve(null);
                var dbRequest = indexedDB.open(_this.dataDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    var database    = event.target.result;
                    var objectStore = database.createObjectStore(_this.dataTable, {keyPath: "id"});
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{    
                        var transaction   = database.transaction([_this.dataTable], 'readwrite');
                        var objectStore   = transaction.objectStore(_this.dataTable);
                        var objectRequest = objectStore.put(object);

                        objectRequest.onerror = function(event) {
                            resolve(false);
                        };

                        objectRequest.onsuccess = function(event) {
                            resolve(true);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }



    /**
     * Creates a new software component object.

     * @param object: The object to create.
     * @return {Promise&lt;boolean>} Success or not
     */
    async _createSoftwareComponent(object){
        const _this = this;
        return new Promise(
            function(resolve, reject) {
                if (object.id === undefined) resolve(null);
                var dbRequest = indexedDB.open(_this.swCompDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    var database    = event.target.result;
                    var objectStore = database.createObjectStore(_this.softwareComponentsTable, {keyPath: "id"});
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{
                        var transaction   = database.transaction([_this.softwareComponentsTable], 'readwrite');
                        var objectStore   = transaction.objectStore(_this.softwareComponentsTable);
                        var objectRequest = objectStore.put(object);

                        objectRequest.onerror = function(event) {
                            resolve(false);
                        };

                        objectRequest.onsuccess = function(event) {
                            resolve(true);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }


    /**
     * Creates a new smart service configuration item.
     * @param object: The object to create.
     * @return {Promise&lt;boolean>} Success or not
     */
    async _createSmartServiceConfiguration(object){
        const _this = this;

        return new Promise(
            function(resolve, reject) {
                if (object.id === undefined) resolve(null);
                var dbRequest = indexedDB.open(_this.sscItemDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    var database    = event.target.result;
                    var objectStore = database.createObjectStore(_this.smartServiceConfigurationTable, {keyPath: "id"});
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{
                        var transaction   = database.transaction([_this.smartServiceConfigurationTable], 'readwrite');
                        var objectStore   = transaction.objectStore(_this.smartServiceConfigurationTable);
                        var objectRequest = objectStore.put(object);
                        objectRequest.onerror = function(event) {
                            resolve(false);
                        };

                        objectRequest.onsuccess = function(event) {
                            resolve(true);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }


    /**
     * Returns all cached model item IDs accessible withing the database.
     * @return {Promise&lt;Array>} The IDs of the stored model items.
     */
    async getModelItemIDs(){
        const _this = this;
        return new Promise(
            function(resolve, reject) {
                var dbRequest = indexedDB.open(_this.modelDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    event.target.transaction.abort();
                    resolve(null);
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{
                        var transaction   = database.transaction([_this.modelTable]);
                        var objectStore   = transaction.objectStore(_this.modelTable);
                        var objectRequest = objectStore.getAll();

                        objectRequest.onerror = function(event) {
                            resolve(null);
                        };

                        objectRequest.onsuccess = function(event) {
                            if (objectRequest.result) resolve(objectRequest.result);
                            else resolve(null);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }

    /**
     * Returns all cached domain item IDs accessible withing the database.
     * @return {Promise&lt;Array>} The IDs of the stored domain items.
     */
    async getDomainItemIDs(){
        const _this = this;
        return new Promise(
            function(resolve, reject) {
                var dbRequest = indexedDB.open(_this.dataDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    event.target.transaction.abort();
                    resolve(null);
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{    
                        var transaction   = database.transaction([_this.modelTable]);
                        var objectStore   = transaction.objectStore(_this.modelTable);
                        var objectRequest = objectStore.getAll();

                        objectRequest.onerror = function(event) {
                            resolve(null);
                        };

                        objectRequest.onsuccess = function(event) {
                            if (objectRequest.result) resolve(objectRequest.result);
                            else resolve(null);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }

    /**
     * Returns all cached software item names accessible withing the database.
     * @return {Promise&lt;Array>} The names of the cached software items.
     */
    async getSoftwareItemIDs(){
        const _this = this;
        return new Promise(
            function(resolve, reject) {
                var dbRequest = indexedDB.open(_this.swCompDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    // Objectstore does not exist. Nothing to load
                    event.target.transaction.abort();
                    resolve(null);
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{
                        var transaction   = database.transaction([_this.softwareComponentsTable]);
                        var objectStore   = transaction.objectStore(_this.softwareComponentsTable);
                        var objectRequest = objectStore.getAll();

                        objectRequest.onerror = function(event) {
                            resolve(null);
                        };

                        objectRequest.onsuccess = function(event) {
                            if (objectRequest.result) resolve(objectRequest.result);
                            else resolve(null);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }


    /**
     * Returns all cached Smart Service Configuration Item IDs accessible withing the database.
     * @return {Promise&lt;Array>} The IDs of the stored Smart Service Configuration Items.
     */
    async getSmartServiceConfigurationItemIDs(){
        const _this = this;
        return new Promise(
            function(resolve, reject) {
                var dbRequest = indexedDB.open(_this.sscItemDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    event.target.transaction.abort();
                    resolve(null);
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{    
                        var transaction   = database.transaction([_this.smartServiceConfigurationTable]);
                        var objectStore   = transaction.objectStore(_this.smartServiceConfigurationTable);
                        var objectRequest = objectStore.getAll();

                        objectRequest.onerror = function(event) {
                            resolve(null);
                        };

                        objectRequest.onsuccess = function(event) {
                            if (objectRequest.result) resolve(objectRequest.result);
                            else resolve(null);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }


    /**
     * Reads a new model object.
     * @param query: DatabaseQuery defining the query parameter e.g. id, type etc. of the data.
     * @returns {Promise&lt;Array>} Array of objects.
     */
    async _readModel(query){
        const _this = this;
        const id = query.ressource;
        return new Promise(
            function(resolve, reject) {
                var dbRequest = indexedDB.open(_this.modelDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {

                    event.target.transaction.abort();
                    resolve(null);
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{    
                        var transaction   = database.transaction([_this.modelTable]);
                        var objectStore   = transaction.objectStore(_this.modelTable);
                        var objectRequest = objectStore.get(id);

                        objectRequest.onerror = function(event) {
                            resolve(null);
                        };

                        objectRequest.onsuccess = function(event) {
                            if (objectRequest.result) resolve(objectRequest.result);
                            else resolve(null);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }


    /**
     * Updates a model object.
     * @param query: DatabaseQuery defining the query parameter e.g. id, type etc. of the data.
     * @param object: The object to be updated.
     * @return {Promise&lt;boolean>} Success or not
     */
    async _updateModel(query, object){
        const _this = this;
        const id = query.ressource;
        return new Promise(
            function(resolve, reject) {
                if (id === undefined) resolve(null);
                var dbRequest = indexedDB.open(_this.modelDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    var database    = event.target.result;
                    var objectStore = database.createObjectStore(_this.modelTable, {keyPath: "id"});
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{
                        var transaction   = database.transaction([_this.modelTable], 'readwrite');
                        var objectStore   = transaction.objectStore(_this.modelTable);
                        var objectRequest = objectStore.put(object);

                        objectRequest.onerror = function(event) {
                            resolve(false);
                        };

                        objectRequest.onsuccess = function(event) {
                            resolve(true);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }




    /**
     * Reads a new data object.
     * @param query: DatabaseQuery defining the query parameter e.g. id, type etc. of the data.
     * @returns {Promise&lt;Array>} Array of objects.
     */
    async _readData(query){
        const id = query.ressource;
        const _this = this;
        return new Promise(
            function(resolve, reject) {
                var dbRequest = indexedDB.open(_this.dataDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    // Objectstore does not exist. Nothing to load
                    event.target.transaction.abort();
                    resolve(null);
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{    
                        var transaction   = database.transaction([_this.dataTable]);
                        var objectStore   = transaction.objectStore(_this.dataTable);
                        var objectRequest = objectStore.get(id);

                        objectRequest.onerror = function(event) {
                            resolve(null);
                        };

                        objectRequest.onsuccess = function(event) {
                            if (objectRequest.result) resolve(objectRequest.result);
                            else resolve(null);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }

    /**
     * Reads a new software component object.
     * @param query: DatabaseQuery defining the query parameter e.g. id, type etc. of the data.
     * @returns {Promise&lt;Array>} Array of objects.
     */
    async _readSoftwareComponent(query){
        const id = query.ressource;
        const _this = this;
        return new Promise(
            function(resolve, reject) {
                var dbRequest = indexedDB.open(_this.swCompDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    // Objectstore does not exist. Nothing to load
                    event.target.transaction.abort();
                    resolve(null);
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try {
                        var transaction   = database.transaction([_this.softwareComponentsTable]);
                        var objectStore   = transaction.objectStore(_this.softwareComponentsTable);
                        var objectRequest = objectStore.get(id);

                        objectRequest.onerror = function(event) {
                            resolve(null);
                        };

                        objectRequest.onsuccess = function(event) {
                            if (objectRequest.result) resolve(objectRequest.result);
                            else {
                                resolve(null);
                            }
                        };
                    } catch (e) {
                        resolve(null);
                    }

                };
            }
        );
    }



    /**
     * Reads a new smart service configuration item.
     * @param query: DatabaseQuery defining the query parameter e.g. id, type etc. of the data.
     * @returns {Promise&lt;Array>} Array of objects.
     */
    async _readSmartServiceConfiguration(query){
        const id = query.ressource;
        const _this = this;
        return new Promise(
            function(resolve, reject) {
                var dbRequest = indexedDB.open(_this.sscItemDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    // Objectstore does not exist. Nothing to load
                    event.target.transaction.abort();
                    resolve(null);
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{
                        var transaction   = database.transaction([_this.smartServiceConfigurationTable]);
                        var objectStore   = transaction.objectStore(_this.smartServiceConfigurationTable);
                        var objectRequest = objectStore.get(id);

                        objectRequest.onerror = function(event) {
                            resolve(null);
                        };

                        objectRequest.onsuccess = function(event) {
                            if (objectRequest.result) resolve(objectRequest.result);
                            else resolve(null);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }

    /**
     * Updates a data object.
     * @param query: DatabaseQuery defining the query parameter e.g. id, type etc. of the data.
     * @param object: The object to be updated.
     * @return {Promise&lt;boolean>} Success or not
     */
    async _updateData(query, object){
        const _this = this;
        const id = query.ressource;
        return new Promise(
            function(resolve, reject) {
                if (id === undefined) resolve(null);
                var dbRequest = indexedDB.open(_this.dataDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    var database    = event.target.result;
                    var objectStore = database.createObjectStore(_this.dataTable, {keyPath: "id"});
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{
                        var transaction   = database.transaction([_this.dataTable], 'readwrite');
                        var objectStore   = transaction.objectStore(_this.dataTable);
                        var objectRequest = objectStore.put(object);

                        objectRequest.onerror = function(event) {
                            resolve(false);
                        };

                        objectRequest.onsuccess = function(event) {
                            resolve(true);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }

    /**
     * Updates a software component object.
     * @param query: DatabaseQuery defining the query parameter e.g. id, type etc. of the data.
     * @param object: The object to be updated.
     * @return {Promise&lt;boolean>} Success or not
     */
    async _updateSoftwareComponent(query, object){
        const _this = this;
        const id = query.ressource;
        return new Promise(
            function(resolve, reject) {
                if (id === undefined) resolve(null);
                var dbRequest = indexedDB.open(_this.swCompDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    var database    = event.target.result;
                    var objectStore = database.createObjectStore(_this.softwareComponentsTable, {keyPath: "id"});
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{
                        var transaction   = database.transaction([_this.softwareComponentsTable], 'readwrite');
                        var objectStore   = transaction.objectStore(_this.softwareComponentsTable);
                        var objectRequest = objectStore.put(object);

                        objectRequest.onerror = function(event) {
                            resolve(false);
                        };

                        objectRequest.onsuccess = function(event) {
                            resolve(true);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }


    /**
     * Updates a new smart service configuration item.
     * @param query: DatabaseQuery defining the query parameter e.g. id, type etc. of the data.
     * @param object: The object to be updated.
     * @return {Promise&lt;boolean>} Success or not
     */
    async _updateSmartServiceConfiguration(query, object){
        const _this = this;
        const id = query.ressource;
        return new Promise(
            function(resolve, reject) {
                if (id === undefined) resolve(null);
                var dbRequest = indexedDB.open(_this.sscItemDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    var database    = event.target.result;
                    var objectStore = database.createObjectStore(_this.smartServiceConfigurationTable, {keyPath: "id"});
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{
                        var transaction   = database.transaction([_this.smartServiceConfigurationTable], 'readwrite');
                        var objectStore   = transaction.objectStore(_this.smartServiceConfigurationTable);
                        var objectRequest = objectStore.put(object);

                        objectRequest.onerror = function(event) {
                            resolve(false);
                        };

                        objectRequest.onsuccess = function(event) {
                            resolve(true);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }

    /**
     * Deletes a data object.
     * @param query: DatabaseQuery defining the query parameter e.g. id, type etc. of the data.
     * @return {Promise&lt;boolean>} Success or not
     */
    async _deleteData(query){
        const id = query.ressource;
        const _this = this;
        return new Promise(
            function(resolve, reject) {
                if (id === undefined) resolve(null);
                var dbRequest = indexedDB.open(_this.dataDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    var database    = event.target.result;
                    var objectStore = database.createObjectStore(_this.dataTable, {keyPath: "id"});
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{
                        var transaction   = database.transaction([_this.dataTable], 'readwrite');
                        var objectStore   = transaction.objectStore(_this.dataTable);
                        var objectRequest = objectStore.delete(id);

                        objectRequest.onerror = function(event) {
                            resolve(false);
                        };

                        objectRequest.onsuccess = function(event) {
                            resolve(true);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }

    /**
     * Deletes a software component object.
     * @param query: DatabaseQuery defining the query parameter e.g. id, type etc. of the data.
     * @return {Promise&lt;boolean>} Success or not
     */
    async _deleteSoftwareComponent(query){
        const id = query.ressource;
        const _this = this;
        return new Promise(
            function(resolve, reject) {
                if (id === undefined) resolve(null);
                var dbRequest = indexedDB.open(_this.swCompDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    var database    = event.target.result;
                    var objectStore = database.createObjectStore(_this.softwareComponentsTable, {keyPath: "id"});
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{
                        var transaction   = database.transaction([_this.softwareComponentsTable], 'readwrite');
                        var objectStore   = transaction.objectStore(_this.softwareComponentsTable);
                        var objectRequest = objectStore.delete(id);

                        objectRequest.onerror = function(event) {
                            resolve(false);
                        };

                        objectRequest.onsuccess = function(event) {
                            resolve(true);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }

    /**
     * Deletes a model object.
     * @param query: DatabaseQuery defining the query parameter e.g. id, type etc. of the data.
     * @return {Promise&lt;boolean>} Success or not
     */
    async _deleteModel(query){
        const id = query.ressource;
        const _this = this;
        return new Promise(
            function(resolve, reject) {
                if (id === undefined) resolve(null);
                var dbRequest = indexedDB.open(_this.modelDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    var database    = event.target.result;
                    var objectStore = database.createObjectStore(_this.modelTable, {keyPath: "id"});
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{
                        var transaction   = database.transaction([_this.modelTable], 'readwrite');
                        var objectStore   = transaction.objectStore(_this.modelTable);
                        var objectRequest = objectStore.delete(id);

                        objectRequest.onerror = function(event) {
                            resolve(false);
                        };

                        objectRequest.onsuccess = function(event) {
                            resolve(true);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }

    /**
     * Deletes a smart service configuration item.
     * @param query: DatabaseQuery defining the query parameter e.g. id, type etc. of the data.
     * @return {Promise&lt;boolean>} Success or not
     */
    async _deleteSmartServiceConfiguration(query){
        const id = query.ressource;
        const _this = this;
        return new Promise(
            function(resolve, reject) {
                if (id === undefined) resolve(null);
                var dbRequest = indexedDB.open(_this.sscItemDB);

                dbRequest.onerror = function(event) {
                    resolve(null);
                };

                dbRequest.onupgradeneeded = function(event) {
                    var database    = event.target.result;
                    var objectStore = database.createObjectStore(_this.smartServiceConfigurationTable, {keyPath: "id"});
                };

                dbRequest.onsuccess = function(event) {
                    var database      = event.target.result;
                    try{
                        var transaction   = database.transaction([_this.smartServiceConfigurationTable], 'readwrite');
                        var objectStore   = transaction.objectStore(_this.smartServiceConfigurationTable);
                        var objectRequest = objectStore.delete(id);

                        objectRequest.onerror = function(event) {
                            resolve(false);
                        };

                        objectRequest.onsuccess = function(event) {
                            resolve(true);
                        };
                    } catch (e) {
                        resolve(null);
                    }
                };
            }
        );
    }
}

class WebRTCUPeerCommunicationHandler extends UPeerCommunicationHandler {
    constructor() {
        super();
        this.connectedPeers = {};
        // this dict maintains the list of peers that sent the initial offer. on ICE restart, this peer will try to
        // send the offer again to create connection
        this.initiatedOffer = {};
        // the list of peers that are in webrtc:failed state
        this.failedConn = {};
        // this buffer contains msgs to be sent to the signalling server. if conn to the signalling server fails, the
        // msgs are buffered and on reconnection, sent to the server
        this.bufferSS = [];
        this.rtcConfig = {
            "iceServers": [{ "url": "stun:stun.l.google.com:19302" }]
        };
        this.MSG_TAGS = {
            START: "&lt;START>",
            END: "&lt;END>",
        }
        this.SSCallback = [];


    }

    send(message, I) {

        I.ssConn.send(JSON.stringify(message));
    }
    transfer(targetID, obj) {
        const I = this;
        var returnonfailure = false;
        // already connected to the peer?
        if (this.connectedPeers[targetID]) {
            var sendChannel = this.connectedPeers[targetID].sendChannel;
            if (sendChannel) {
                console.log(sendChannel.readyState)
                if (sendChannel.readyState === "open" || sendChannel.readyState === "closed"  || sendChannel.readyState === "connected") {// we can only send if the send channel is open
                    try {
                        //sendChannel.send(json);
                        this.sendChunckedToPeer(sendChannel, JSON.stringify(obj)); // add smaller packets for large message
                        this.issueStatusUpdate(this, "PEER MESSAGE SEND" + targetID);
                        return true;
                    } catch (err) {
                        console.error(err);
                    }
                } else {
                    I.issueStatusUpdate(I, "PEER SEND CHANNEL STATUS: " + sendChannel.readyState);
                    if (returnonfailure)
                        return false;
                    I.connectedPeers[targetID].onSendChannelOpen = function () {
                        I.issueStatusUpdate(I, "PEER SEND CHANNEL STATUS " + sendChannel.readyState);
                        I.transfer(targetID, obj);
                    };
                }
            } else {
                I.issueStatusUpdate(I, "send channel is not defined");
            }
        } else {
            // attempt to connect to the peer!
            var peer = this.connectToPeer(this, targetID);

            I.onReady = function () {

                I.transfer(targetID, obj);
            };
            // we creat an offer
            peer.localConnection.createOffer({
                iceRestart: false	// https://medium.com/the-making-of-appear-in/ice-restarts-5d759caceda6
            }).then(function (offer) {
                I.initiatedOffer[targetID] = true;
                peer.localConnection.setLocalDescription(offer);
                // we forward the offer to the signaling server
                var msg = I.formatServerMsg("offer", I.identificationHandler.getLocalID(), targetID, offer, null);
                I.send(msg, I);

            }, function (error) {
                I.issueStatusUpdate(I, "Encountered an error while creating offer ", error);

            });
        }
    }
    formatServerMsg(m_type, m_from, m_to, m_content, properties) {
        return {
            type: m_type,
            from: m_from,
            length: m_content.length,
            to: m_to,
            content: m_content,
            properties: properties
        };
    }
    setupEventListener() {
        const I = this;
        this.ssConn = new WebSocket('wss://service-tucana.de:9091');
        //this.ssConn = new WebSocket('ws://localhost:9090');
        this.ssConn.onopen = function () {
            if (I.identificationHandler.getLocalID() != null) {
                var msgLogin = I.formatServerMsg("login",
                    I.identificationHandler.getLocalID(),
                    null, "login", I.identificationHandler.getProperties());
                I.send(msgLogin, I);
            }

        };

        this.ssConn.onmessage = function (msg) {
            //console.log("Got message", msg.data);
            var msgObj = JSON.parse(msg.data);
            switch (msgObj.type) {
                case "login":
                    I.handleLogin(I, msgObj.success);
                    break;
                case "offer":
                    I.handleOffer(I, msgObj.offer, msgObj.from);
                    break;
                case "answer":
                    I.handleAnswer(I, msgObj.answer, msgObj.from);
                    break;
                case "candidate":
                    I.handleCandidate(I, msgObj.candidate, msgObj.from);
                    break;
                case "leave":
                    I.handleLeave(I, msgObj.from);
                    break;
                case "greetings":
                    I.issueStatusUpdate(I, "SS connection available");
                    break;
                case "error":
                    I.onSSError(I, msgObj.error);
                    break;
                case "properties":
                    I.SSCallback[msgObj.id](msgObj.content);
                    break;
                default:
                    break;
            }
        };
        this.ssConn.onerror = function (err) {
            console.log("Error in Login to Signaling Server ", err);
        };


    }
    handleCandidate(I, candidate, from) {
        I.issueStatusUpdate(I, "SS candidate" + from);
        var candidateObj = new RTCIceCandidate(candidate);
        if (I.connectedPeers[from] == null) {
            console.log("Received Candidate from not connected user");
            return;
        }
        I.connectedPeers[from].localConnection.addIceCandidate(candidateObj).then(function () {
            // this value is only for debugging
            I.connectedPeers[from].noCand = I.connectedPeers[from].noCand + 1;
            I.connectedPeers[from].ready = true;
            if (I.onReady)
                I.onReady();
        }, function (error) {
            console.log(error);
        });
    }
    handleLeave(I, from) {
        I.issueStatusUpdate(I, "SS LEAVE " + from);
        if (I.connectedPeers[from]) {
            I.connectedPeers[from].localConnection.onicecandidate = null;
            I.connectedPeers[from].localConnection.close();
            delete I.connectedPeers[from];
            if (I.onPeerDisconnected)
                I.onPeerDisconnected(from);
        }
    }
    handleAnswer(I, answer, from) {
        if (from in I.failedConn) {
            I.failedConn[from] = false
        }
        I.issueStatusUpdate(I, "SS Answer " + from);
        // we set the remote description of the channel we previously created to the answer
        I.connectedPeers[from].localConnection.setRemoteDescription(new RTCSessionDescription(answer));
    }
    handleOffer(I, offer, peerId) {
        var to_connect = true;
        I.initiatedOffer[peerId] = false;

        var peer;
        if (peerId in I.failedConn) {
            if (I.failedConn[peerId] == true) {
                peer = I.connectedPeers[peerId];

                //set to false again
                I.failedConn[peerId] = false;
                to_connect = false;
            }
        }
        if (to_connect) {
            // we received an offer from a peer we create the RTC connection
            peer = I.connectToPeer(I, peerId);
        }

        I.issueStatusUpdate(I, " SS OFFER " + peerId);
        // we set the connection remote description to the given offer!
        peer.localConnection.setRemoteDescription(new RTCSessionDescription(offer));
        peer.localConnection.createAnswer(function (answer) {
            // we creat an answer and set the channel local description to the answer!
            peer.localConnection.setLocalDescription(answer);
            var msg = I.formatServerMsg("answer", I.identificationHandler.getLocalID(), peerId, answer, null);
            I.send(msg, I);
        }, function (error) {
            I.issueStatusUpdate(I, "create answer: " + error);
        });

    }
    handleLogin(I, success) {
        if (success) {
            I.issueStatusUpdate(I, "SS LOGGED IN");
        } else {
            I.onSSError(I, "Failed to Login");
        }
    }
    onSSError(I, err) {
        console.log(err);
    }
    issueStatusUpdate(I, status) {
        if (I &amp;&amp; I.onStatusUpdate) {
            I.onStatusUpdate(status);
        }
        console.log("[PeerCommunication] ", status);
    }
    async handleRequest(req){
        super.handleRequest(req);
    }

    async handleResponse(req,res){
        super.handleResponse(req,res);
    }
    connectToPeer(I, peerId) {
        var peer = I.connectedPeers[peerId] = new Object();
        peer.ready = false;
        peer.noCand = 0;
        // Creating local channel for it
        peer.localConnection = new RTCPeerConnection(this.rtcConfig);
        peer.localConnection.onicecandidate = function (event) {
            if (event.candidate) {
                I.issueStatusUpdate(I, "candidate " + peerId);
                var msg = I.formatServerMsg("candidate", I.identificationHandler.getLocalID(), peerId, event.candidate, null);
                I.send(msg, I);

            }
        };
        peer.localConnection.oniceconnectionstatechange = function (event) {
            I.issueStatusUpdate(I, " PEER CONNECTION STATUS " + peerId + " is " + peer.localConnection.iceConnectionState);
            localStorage.setItem("Connected peer", peerId)

            if(peer.localConnection.iceConnectionState == 'disconnected') {
                var msg = I.formatServerMsg("leave", 
                I.identificationHandler.getLocalID(),
                null, "leave", I.identificationHandler.getProperties());
                I.send(msg, I);
            }
            if (peer.localConnection.iceConnectionState == "connected") {// notify that this peer is connected now!
                if (I.onPeerConnected) {
                    I.onPeerConnected(peerId);
                }
            }
            if (peer.localConnection.iceConnectionState == "failed") {
                I.failedConn[peerId] = true;
                // wait for a small amount of time before initiating ice restart.
                setTimeout(function () {

                    if (peerId in I.initiatedOffer) {
                        if (I.initiatedOffer[peerId]) {
                            peer.localConnection.createOffer({
                                iceRestart: true	// https://medium.com/the-making-of-appear-in/ice-restarts-5d759caceda6
                            }).then(function (offer) {
                                peer.localConnection.setLocalDescription(offer);
                                var msg = I.formatServerMsg("offer", I.identificationHandler.getLocalID(), peerId, offer, null);
                                I.send(msg, I);
                            }, function (error) {
                                I.issueStatusUpdate(I, "Encountered an error while performing ICE restart ", error);
                            });
                        }
                    }
                }, 1000);
            }
        };

        //  when receiving data
        peer.localConnection.ondatachannel = function (event) {
            peer.receiveChannel = event.channel;
            var receivedData = new Object();
            var recData = "" ;
            peer.receiveChannel.onmessage = function (event) {
                if (event.data === I.MSG_TAGS.START) {
                    receivedData = "";
                }
                else if (event.data !== I.MSG_TAGS.END &amp;&amp; event.data !== I.MSG_TAGS.START) {              
                    receivedData += event.data;
                }//TODO TEST with real request and response data
                else{
                    recData = JSON.parse(receivedData);
                    console.log("Complete message received :  " + receivedData);
                }
                
                if (recData.res) {
                    I.handleResponse(recData.req, recData.res);
                    console.log("Response message received :  "+ localStorage.getItem("permission"));
                    
                }
                else if (recData.type == "req") {
                    I.handleRequest(recData);
                    console.log("Request message received :  "+ localStorage.getItem("permission"));
                }

            };
            peer.receiveChannel.onclose = function () {
                I.issueStatusUpdate(I, "PEER RECEIEVE CHANNEL STATUS " + peerId + " CLOSED ");
            };
        };

        peer.sendChannel = peer.localConnection.createDataChannel(peerId + "_channel", {
            reliable: true
        });

        peer.sendChannel.onerror = function (error) {
            I.issueStatusUpdate(I, "error on send channel of peer " + peerId + " " + error);
        };

        peer.sendChannel.onopen = function () {
            I.issueStatusUpdate(I, "PEER SEND CHANNEL STATUS: " + peerId + " OPEN ");
            if (I.connectedPeers[peerId].onSendChannelOpen)
                I.connectedPeers[peerId].onSendChannelOpen();
        };

        peer.sendChannel.onclose = function () {
            I.issueStatusUpdate(I, "PEER SEND CHANNEL STATUS: " + peerId + " CLOSED ");
        };
        return peer;

    }
    sendChunckedToPeer(sendChannel, msg){
        const I = this;
        var data = msg;
        var sendMax = data.length;
        var sendValue = 0;
        var curIndex = 0;
        var endIndex = 0;

        var chunkSize = 16384;
        var bufferFullThreshold = 5 * chunkSize;
        var usePolling = true;
        if ( typeof sendChannel.bufferedAmountLowThreshold === 'number') {
            usePolling = false;

            bufferFullThreshold = chunkSize / 2;

            // This is "overcontrol": our high and low thresholds are the same.
            sendChannel.bufferedAmountLowThreshold = bufferFullThreshold;
        }//if

        // Listen for one bufferedamountlow event.
        var listener = function() {
            sendChannel.removeEventListener('bufferedamountlow', listener);
            sendAllData();
        };
        var sendAllData = function() {
            while (sendValue &lt; sendMax) {
                if (sendChannel.bufferedAmount > bufferFullThreshold) {
                    if (usePolling) {
                        setTimeout(sendAllData, 250);
                    } else {
                        sendChannel.addEventListener('bufferedamountlow', listener);
                    }
                    return;
                }
                sendValue += chunkSize;

                endIndex = curIndex + chunkSize > data.length ? data.length : curIndex + chunkSize;
                var msg = data.substring(curIndex, endIndex);
                if (curIndex == 0) {
                    sendChannel.send(I.MSG_TAGS.START);
                }
                sendChannel.send(msg);
                if (endIndex >= data.length) {
                    sendChannel.send(I.MSG_TAGS.END);
                }
                curIndex = endIndex;
            }
        };
        setTimeout(sendAllData, 0);
    }


    async getFilteredPeerIds(properties) {
        const I = this;
        var msg = I.formatServerMsg("properties", this.identificationHandler.getLocalID(), null, {id : I.SSCallback.length, properties:properties});
        return new Promise((resolve, reject) => {
            setTimeout(() => {            
            I.send(msg, I);
            I.SSCallback.push(function(list) {
                console.log("Filterd Ids : ",list);
                resolve(list);})
            
        
        })}, 1500);

    }
}

class RESTAPIBaaSCommunicationHandler extends BaaSCommunicationHandler {
    constructor() {
        super();
    }

    /**
     * This function can be used to fetch software items via REST API.
     * @param {CRUDOperation} crudOperation
     * @return {Array&lt;Promise&lt;Object>>}
     */
    async broadcastSBaaS(crudOperation) {
        const targets = crudOperation.getBroadcastConfiguration().getTargets();
        const promises = [];
        for (let ressource of targets) {
            const options = {
                'headers' : {
                    'Accept' : 'application/javascript'
                }
            };
            promises.push(
                fetch(ressource, options)
                    .then(response => {
                        return response.text();
                    }).then(jsCode => {
                        return {
                            req : crudOperation,
                            res : {success : true, status: 'provided', message: 'Operation was successfully executed.', response : new model.SoftwareItem(ressource, jsCode)}
                        };
                }).catch(error => {
                    return {
                        req : crudOperation,
                        res : {success : false, status: 'failed', message: 'Failed broadcast request.'}
                    };
                })
            );
        }
        return await Promise.all(promises);
    }

    /**
     * This function can be used to fetch domain items via REST API.
     * @param {CRUDOperation} crudOperation
     * @return {Array&lt;Promise&lt;Object>>}
     */
    async broadcastDBaaS(crudOperation) {
        const targets = crudOperation.getBroadcastConfiguration().getTargets();
        const promises = [];
        for (let ressource of targets) {
            const options = {
                'headers' : {
                    'Accept' : 'application/json'
                }
            };

            promises.push(
                fetch(ressource, options)
                    .then(response => {
                        return response.json();
                    }) .then(jsonObject => {
                        return {success : true, status: 'provided', message: 'Operation was successfully executed.', response : new model.DomainItem(ressource, jsonObject)};
                    })
            );
        }
        return await Promise.all(promises);
    }

    /**
     * This function can be used to fetch smart service configuration items via REST API.
     * @param {CRUDOperation} crudOperation
     * @return {Array&lt;Promise&lt;Object>>}
     */
    async broadcastSSCBaaS(crudOperation) {
        const targets = crudOperation.getBroadcastConfiguration().getTargets();
        const promises = [];
        for (let ressource of targets) {
            const options = {
                'headers' : {
                    'Accept' : 'application/json'
                }
            };
            promises.push(
                fetch(ressource, options)
                    .then(response => {
                        return response.json();
                    }) .then(jsonObject => {
                        return {success : true, status: 'provided', message: 'Operation was successfully executed.', response : new model.SmartServiceConfigurationItem(ressource, jsonObject.version, jsonObject.configuration, jsonObject.context)};
                    })
            );
        }
        return await Promise.all(promises);
    }

    /**
     * This function can be used to fetch model items via REST API.
     * @param {CRUDOperation} crudOperation
     * @return {Array&lt;Promise&lt;Object>>}
     */
    async broadcastMBaaS(crudOperation) {
        const targets = crudOperation.getBroadcastConfiguration().getTargets();
        const promises = [];
        for (let ressource of targets) {
            const options = {
                'headers' : {
                    'Accept' : 'application/json'
                }
            };
            promises.push(
                fetch(ressource, options)
                    .then(response => {
                        return response.json();
                    }) .then(jsonObject => {
                        return {success : true, status: 'provided', message: 'Operation was successfully executed.', response : new model.ModelItem(ressource, jsonObject)};
                    })
            );
        }
        return await Promise.all(promises);
    }
}
class Browser extends TENVIdentificationHandler {
    constructor() {
        super();
    }
    getLocalID() {
        return true;
    }
    getProperties() {
        return true;
    }
    getName() {
        return true;
    }
    getType() {
        return true;
    }

}

class BrowserFingerprintIdentificationHandler extends TENVIdentificationHandler {


    /**
     * Creates a dynamic login form and stores the given information(Name, Keywords, commercial use...) in the localStorage
     * and uses Fingerprintjs2 to create a unique ID of the user. If the user already has an id
     * in the localStorage the login form will not pop up.
     * @param signUpFormId
     * @param logoutButtonId
     */

    constructor(signUpFormId, logoutButtonId) {
        super();

        var signUpForm = document.getElementById(signUpFormId);
        var logoutButton = document.getElementById(logoutButtonId);
        var span = document.createElement("SPAN");

        span.className = "close";
        span.title = "Close Modal";
        span.innerHTML = '&amp;times';
        span.onclick = function () {
            signUpForm.style.display = 'none';
            localStorage.setItem("id", null);

        };

        signUpForm.appendChild(span);

        var form = document.createElement("form");
        form.className = "modal-content";

        var container = document.createElement("id");
        container.className = "container";
        signUpForm.appendChild(form);


        var container = document.createElement("div");
        container.className = "container";
        container.id = "signUpContainer";
        form.appendChild(container);

        signUpForm.style.display = 'block';

        function createCheckbox(labelContent, id, container) {
            var d = document.createElement("div");
            var v = document.createElement("input");
            v.type = "checkbox";
            v.id = id;

            var label = document.createElement('label');
            label.htmlFor = "id";
            label.appendChild(document.createTextNode(labelContent));
            d.appendChild(v);
            d.appendChild(label);
            container.appendChild(d);

        }

        function createTextField(id, container, placeholder, labelContent) {
            var keywordsFieldLabel = document.createElement("label");
            keywordsFieldLabel.innerText = "\n" + labelContent;

            var keywordField = document.createElement("input");
            keywordField.type = "text";
            keywordField.id = id;
            keywordField.placeholder = placeholder;

            container.appendChild(keywordsFieldLabel);
            container.appendChild(keywordField);
        }



        var h1 = document.createElement("h4");
        h1.innerText = "Login";
        container.appendChild(h1);


        var p = document.createElement("P");
        p.innerText = "Become part of our community!";
        container.appendChild(p);


        createTextField("nameField", container, "Name", "Name");
        //createTextField("keywordField", container, "Enter some Keywords", "Keywords");
        //createCheckbox("Commercial use", "commercialBox", container);
        //createCheckbox("Content Offering", "contentOffering", container);
        createCheckbox("Chocolate Producer", "producer", container);
        createCheckbox("SAS Provider", "provider", container);
        createCheckbox("Guest", "guest", container);


        var cancelLabel = document.createElement('label');
        cancelLabel.innerText = "Cancel";
        var cancelButton = document.createElement("button");
        cancelButton.onclick = "document.getElementById('" + signUpFormId + "').style.display='none'";
        cancelButton.type = "button";
        cancelButton.className = "cancelbtn submit-button";
        cancelButton.appendChild(cancelLabel);

        var submitLabel = document.createElement('label');
        submitLabel.innerText = "Submit";
        var submitButton = document.createElement("button");
        submitButton.onclick = "document.getElementById('" + signUpFormId + "').style.display='none'";
        submitButton.id = "submitButton";
        submitButton.className = "submit-button";
        submitButton.appendChild(submitLabel);

        var buttonDiv = document.createElement("div");
        buttonDiv.className = "clearfix";

        buttonDiv.appendChild(cancelButton);
        buttonDiv.appendChild(submitButton);
        container.appendChild(buttonDiv);


        this.localId = localStorage.getItem("id");
        this.name = localStorage.getItem("name");
        this.producer = localStorage.getItem("producer");
        this.provider = localStorage.getItem("provider");
        this.guest = localStorage.getItem("guest");


        logoutButton.addEventListener("click", function (e) {
            localStorage.clear();
            this.localId = null;
            localStorage.setItem("id", null);
            location.reload(true);

        });

        //take a fingerprint and store it in localStorage
        Fingerprint2.get(function (components) {
            let localId = Fingerprint2.x64hash128(components.map(function (pair) { // create an ID from the hashed components
                return pair.value;
            }).join(), 31);

            localStorage.setItem("id_tmp", localId);

        });


        if (localStorage.getItem("id")) {

            console.log("User already logged in with id: " + localStorage.getItem("id"));

            document.getElementById(signUpFormId).style.display = 'none';

        } else {

            //store the given information in the localStorage when submitButton is pressed
           submitButton.addEventListener("click", function (e) {


            this.name = document.getElementById("nameField").value;
            localStorage.setItem("name", this.name);
            
            if (this.name == '') {
                alert('you must gave your name to proceed');
                return
            }

                
                //this.keywords = document.getElementById("keywordField").value;
                //localStorage.setItem("keywords", this.keywords);
              /*  if (document.getElementById("modelOffering").checked) {
                    localStorage.setItem("modelOffering", true);
                    this.modelOffering = true;
                } else {
                    localStorage.setItem("modelOffering", false);
                    this.modelOffering = false;
                }
                if (document.getElementById("contentOffering").checked) {
                    localStorage.setItem("contentOffering", true);
                    this.contentOffering = true;
                } else {
                    localStorage.setItem("contentOffering", false);
                    this.contentOffering = false;
                }
                if (document.getElementById("softwareOffering").checked) {
                    localStorage.setItem("softwareOffering", true);
                    this.softwareOffering = true;
                } else {
                    localStorage.setItem("softwareOffering", false);
                    this.softwareOffering = false;
                }
                if (document.getElementById("commercialBox").checked) {
                    localStorage.setItem("commercial", true);
                    this.commercial = true;
                }*/ 
                this.producer = false;
                this.provider = false;
                this.guest = false;
                if (document.getElementById("producer").checked) {
                    localStorage.setItem("producer", true);
                    localStorage.setItem("role", true);
                    this.role = true;
                    this.producer = true;
                } 
                else {
                    localStorage.setItem("producer", false);
                }

                if (document.getElementById("provider").checked) {
                    localStorage.setItem("provider", true);
                    localStorage.setItem("role", true);
                    this.role = true;
                    this.provider = true;
                } 
                else {
                    localStorage.setItem("provider", false);
                }

                if (document.getElementById("guest").checked) {
                    localStorage.setItem("producer", true);
                    localStorage.setItem("guest", false);
                    localStorage.setItem("role", true);
                    this.role = true;
                    this.producer = true;
                } 
                else {
                    localStorage.setItem("guest", false);
                }


                if (this.producer == false &amp;&amp; this.provider == false &amp;&amp; this.guest == false) {
                    alert("You can only seek help but can't use any service as you did'nt choose any role!");
                    var answer = window.confirm("You want to choose Role?")
                    if (answer) {
                        return
                    }
                    else{
                        localStorage.setItem("role", false);
                        this.role = false;
                    }
                }
                
                this.localId = localStorage.getItem("id_tmp");
                localStorage.setItem("id", this.localId);
                location.reload(true);
                /*window.close();
                if (this.producer == true) {
                    window.open("../EVAREST-HMI/html/main.html?role="+this.name);
                }
                if (this.provider == true &amp;&amp; this.guest == false) {
                    window.open("../EVAREST-HMI/html/main10.html?role="+this.name);
                }
                if (this.guest == true) {
                    window.open("../EVAREST-HMI/html/main20.html?role="+this.name);
                }*/



            });

            /*show register form*/
            signUpForm.style.display = 'block';
            


        }
        this.properties = {
            localId: this.localId,
            commercial: this.producer,
            software: this.provider,
            content: this.guest,
            model: 'true',
            keywords: "k",
            name: "n"

        }
        console.log("Properties at login");
        console.log(this.properties);
    }

    /**
     * Returns the local id of the peer.
     * @return {String}: The local id of the peer.
     */
    getLocalID() {
        return this.localId;
    }

    /**
     * Returns the properties of the Peer.
     * @return {Array}: All properties of the peer.
     */
    getProperties() {
        return this.properties;
    }

    /**
     * Returns the name of the peer.
     * @return {String}: The name of the peer.
     */
    getName() {
        return this.name;
    }

    /**
     * Returns the type of the peer.
     * @return {String}: The type of the peer.
     */
    getType() {
        return this.commercial;
    }

    /**
     * Returns the geographic information of the peer.
     * @return {String}: The geographic information of the peer.
     */
    async getGeography() {

        var result = {};

        function reverseGeocode(latitude, longitude, res) {


            var settings = {
                "async": true,
                "crossDomain": true,
                "url": "https://us1.locationiq.com/v1/reverse.php?key=95a3c547a4d595&amp;lat=" + latitude + "&amp;lon=" + longitude + "&amp;format=json",
                "method": "GET"
            }

            return $.ajax(settings).done(function (response) {

                res();
            });

        }

        let promise = new Promise(function (res, rej) {
                navigator.geolocation.getCurrentPosition(function (position) {
                    result.geo = reverseGeocode(position.coords.latitude, position.coords.longitude, res);
                })
            }
        );

        await promise;

        console.log(result.geo.responseJSON);

        return result.geo;
    }

    /**
     * Returns the software offering of the peer.
     * @return {String}: The software offering of the peer.
     */
    getSoftwareOffering() {
        return this.softwareOffering;
    }

    /**
     * Returns the model offering of the peer.
     * @return {String}: The model offering of the peer.
     */
    getModelOffering() {
        return this.modelOffering;
    }

    /**
     * Returns the content offering of the peer.
     * @return {String}: The content offering of the peer.
     */
    getContentOffering() {
        return this.contentOffering;
    }

    /**
     * Returns the keywords of the peer.
     * @return {Array}: The keywords of the peer.
     */
    getKeywords() {
        return this.keywords;
    }
}


module.exports.DOMUIAdapter = require('./coreplatform/ui_adapters/uiAdapter').domAdapter;
module.exports.BrowserFingerprintIdentificationHandler = BrowserFingerprintIdentificationHandler;
module.exports.Browser = Browser;
module.exports.IndexedDBDatabaseHandler = IndexedDBDatabaseHandler;
module.exports.RESTAPIBaaSCommunicationHandler = RESTAPIBaaSCommunicationHandler;
module.exports.WebRTCUPeerCommunicationHandler = WebRTCUPeerCommunicationHandler;

</code></pre>
        </article>
    </section>




</div>

<footer>
    <img class="logo" src="http://iss.uni-saarland.de/workspace/grayscale/img/logo_iss1.png" style="width: 90px; height: 30px">
    <div class="footer-text">NHN Entertainment. Frontend Development Lab</div>
</footer>
<script>prettyPrint();</script>
<script src="scripts/jquery.min.js"></script>
<script src="scripts/tui-doc.js"></script>
<script src="scripts/linenumber.js"></script>

    <script>
        var id = '_sub'.replace(/"/g, '_');
        var selectedApi = document.getElementById(id); // do not use jquery selector
        var $selectedApi = $(selectedApi);

        $selectedApi.removeClass('hidden');
        $selectedApi.parent().find('.glyphicon').removeClass('glyphicon-plus').addClass('glyphicon-minus');
        showLnbApi();
    </script>

</body>
</html>
